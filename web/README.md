# Haywire Web UI

Web-based version of Haywire memory introspection tool using Vue 3 and WebAssembly.

## Architecture

- **Vue 3** - UI framework
- **WebAssembly** - Reuses the C++ `memory_renderer.cpp` compiled to WASM for native performance
- **File System API** - Direct access to memory-mapped file (`/tmp/haywire-vm-mem`)
- **WebSocket** - Minimal bridge for QMP commands (VA→PA translation)

## Setup

### 1. Install Dependencies
```bash
npm install
```

### 2. Build WebAssembly Module
```bash
# Requires emscripten (emcc) to be installed
npm run build-wasm
```

### 3. Add SSL Certificates
Place your SSL certificates in `ssl-stuff/`:
- `localhost-key.pem`
- `localhost.pem`

### 4. Run Development Server
```bash
npm run dev
```

The app will be available at `https://localhost:3000`

## Project Structure

```
web/
├── wasm/                        # WebAssembly wrapper
│   ├── memory_renderer_wasm.cpp   # C wrapper (DO NOT modify rendering logic!)
│   └── build_wasm.sh              # Emscripten build script
│
├── src/
│   ├── components/
│   │   ├── MemoryCanvas.vue      # Main memory visualization
│   │   ├── ProcessSelector.vue   # Process selection from beacons
│   │   └── BitmapViewer.vue      # Mini floating viewers
│   │
│   ├── composables/
│   │   ├── useWasmRenderer.ts    # WASM module interface
│   │   ├── useFileSystemAPI.ts   # File System API for memory access
│   │   └── useQmpBridge.ts       # WebSocket to QMP bridge
│   │
│   └── App.vue                   # Main application
│
└── public/
    └── wasm/                     # Built WASM files
        └── memory_renderer.js    # Generated by build script
```

## Key Features

- **Native Performance**: Reuses exact C++ rendering code via WASM
- **Local Only**: All data stays on your machine, no cloud backend
- **Direct Memory Access**: Uses File System API to read VM memory file
- **Real-time Updates**: WebSocket connection for live memory changes

## Important Notes

1. **DO NOT modify the hex pixel renderer logic** in `memory_renderer_wasm.cpp`. It's a thin wrapper around the existing C++ code to avoid breaking the complex rendering.

2. **Chrome/Edge required** for File System API support

3. **HTTPS required** for security features (File System API, SharedArrayBuffer)

## Building for Production

```bash
npm run build
```

The built files will be in `dist/` directory.